<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Cool Website Games</title>
    <style>
        body {
        font-family: Arial, sans-serif;
        background: #222;
        color: #fff;
        text-align: center;
        margin: 0;
        padding: 0;
        min-height: 100vh;
    }

    #menu,
    #tictactoe,
    #pong,
    #connectfour,
    #battleship,
    #memorymatch,
    #gofish,
    #reversi {
        margin-top: 40px;
        display: none; /* Ensures all games are initially hidden */
    }

    #menu {
        display: block; /* Makes sure menu is the only thing shown initially */
    }

    button,
    .ttt-cell {
        font-size: 1.2em;
        padding: 10px 20px;
        margin: 10px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        transition: background-color 0.3s ease, color 0.3s ease;
    }

    button:hover,
    .ttt-cell:hover {
        background-color: #555;
        color: #eee;
    }

    /*Tic Tac Toe*/
    #tictactoe {
        background: #3498db;
    }

    .ttt-board {
        display: grid;
        grid-template-columns: repeat(3, 100px);
        grid-template-rows: repeat(3, 100px);
        gap: 5px;
        justify-content: center;
        margin: 20px auto;
    }

    .ttt-cell {
        width: 100px;
        height: 100px;
        background: #2980b9;
        color: #fff;
        font-size: 3em;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        transition: background 0.2s;
    }

    .ttt-cell:hover {
        background: #34495e;
    }

    #ttt-result {
        font-size: 1.5em;
        margin-bottom: 20px;
    }

    /*Pong*/
    #pong {
        background: #f39c12;
    }

    #pong-canvas {
        background: #000;
        display: block;
        margin: 20px auto;
        border: 2px solid #fff;
    }

    /*Connect Four*/
    #connectfour {
        background: #2ecc71;
    }

    #connectfour .container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
    }

    #game-grid {
        display: grid;
        grid-template-columns: repeat(7, 70px);
        grid-template-rows: repeat(6, 70px);
        gap: 5px;
        margin-bottom: 15px;
        background: #c0392b;
        padding: 5px;
        border-radius: 8px;
    }

    #connectfour button {
        width: 70px;
        height: 70px;
        font-size: 2em;
        cursor: pointer;
        background: #34495e;
        color: white;
        border: 2px solid #c0392b;
        border-radius: 50%;
        transition: background 0.3s, transform 0.2s;
    }

    #connectfour button:hover {
        background: #2c3e50;
        transform: scale(1.05);
    }

    #connectfour button:disabled {
        background: #7f8c8d;
        cursor: not-allowed;
        opacity: 0.6;
    }

    #connectfour button[data-piece="X"],
    #connectfour button[data-piece="O"] {
        color: #f1c40f;
    }

    #connectfour .cf-large-btn {
        width: 200px;
    }

    /*Battleship*/
    #battleship {
        background: #9b59b6;
    }

    .boards-container {
        display: flex;
        justify-content: center;
        gap: 48px;
        margin: 24px 0;
        flex-wrap: wrap;
    }

    .board-wrap {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .board-label {
        margin-bottom: 8px;
        font-size: 1.1em;
        font-weight: bold;
    }

    .board {
        display: grid;
        grid-template-columns: repeat(8, 40px);
        grid-template-rows: repeat(8, 40px);
        gap: 3px;
        background: #111;
        border-radius: 8px;
        padding: 5px;
    }

    .cell {
        width: 40px;
        height: 40px;
        background: #333;
        border-radius: 4px;
        font-size: 1.5em;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.18s, color 0.18s;
    }

    .cell.ship {
        background: #2679ff;
    }

    .cell.hit {
        background: #e74c3c;
        color: #fff;
        font-weight: bold;
        animation: pop 0.28s;
    }

    .cell.miss {
        background: #888;
        color: #fff;
        font-weight: bold;
        animation: pop 0.18s;
    }

    .cell.target {
        cursor: pointer;
    }

    .cell.sunk {
        background: #2ecc40;
        color: #fff;
    }

    @keyframes pop {
        0% {
            transform: scale(1);
        }

        50% {
            transform: scale(1.25);
        }

        100% {
            transform: scale(1);
        }
    }

    /*Memory Match*/
    #memorymatch {
        background: #e67e22;
    }

    #memory-board {
        display: grid;
        grid-template-columns: repeat(4, 100px);
        grid-template-rows: repeat(4, 100px);
        gap: 15px;
        justify-content: center;
        margin: 24px auto 16px auto;
        max-width: 420px;
    }

    .card {
        background: #d35400;
        color: #d35400;
        font-size: 3em;
        border-radius: 12px;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s, color 0.2s, transform 0.1s;
        height: 100px;
        width: 100px;
    }

    .card.flipped,
    .card.matched {
        background: #3498db;
        color: #fff;
        cursor: default;
        transform: scale(1.08);
    }

    .card.matched {
        background: #2ecc40;
        color: #fff;
        cursor: default;
        animation: pop 0.3s;
    }

    /*Go Fish*/
    #gofish {
        background: #16a085;
    }

    #gofish .card {
        width: 70px;
        height: 90px;
    }

    #gofish button {
        transition: background-color 0.3s ease, color 0.3s ease;
    }

    #gofish button:hover {
        background-color: #f1c40f;
        color: #333;
    }
    /*Reversi*/
    #reversi {
    background: #27ae60;
    }

    #reversi h2 {
        margin-bottom: 12px;
    }

    #reversi #game-board {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px auto;
        width: 100%;
        flex-direction: column;
    }

    #reversi .board {
        border: 4px solid #1c2833;
        background: #1e8449;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        margin: 0 auto;
    }

    #reversi .row {
        display: flex;
    }

    #reversi .cell {
        width: 60px;
        height: 60px;
        font-size: 2.5em;
        border: 1px solid #1c2833;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;  /* Added box-shadow transition */
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #reversi .cell.valid {
        background: #5ede8b;
        box-shadow: 0 0 8px #5ede8b; /* Added subtle glow for valid moves */
    }

    #reversi .cell:hover.valid {
        background: #43b56a;
        box-shadow: 0 0 12px #43b56a; /* Increased glow on hover */
    }

    #reversi .piece {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    #reversi .piece.black {
        background: #111;
        border: 1px solid #333;
    }

    #reversi .piece.white {
        background: #fff;
        border: 2px solid #ccc;
    }

    #reversi #score,
    #reversi #reversi-status {
        font-size: 1.2em;
        margin-bottom: 10px;
        min-height: 1.6em;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        text-align: center;
    }



    /* General elements */
    h1 {
        color: #eee;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    h2 {
        color: #ddd;
        margin-bottom: 12px;
    }

    #status,
    #battleship-status,
    #moves,
    #gofish #message,
    #gofish #deck-count,
    #reversi #score,
    #reversi-status {
        font-size: 1.2em;
        margin-bottom: 10px;
        min-height: 1.6em;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    }

    /*Responsive adjustments*/
    @media (max-width: 768px) {
        .boards-container {
            flex-direction: column;
            align-items: center;
            gap: 18px;
        }

        #game-grid {
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(6, 50px);
        }

        #connectfour button {
            width: 50px;
            height: 50px;
        }

        .board {
            grid-template-columns: repeat(8, 30px);
            grid-template-rows: repeat(8, 30px);
        }

        .cell {
            width: 30px;
            height: 30px;
        }

        #memory-board {
            grid-template-columns: repeat(4, 80px);
            grid-template-rows: repeat(4, 80px);
        }

        .card {
            width: 80px;
            height: 80px;
        }

        #reversi .cell {
            width: 50px;
            height: 50px;
        }
    }

    </style>
</head>
<body>
    <div id="menu">
        <h1>Cool Website Games</h1>
        <p>Choose a game:</p>
        <button onclick="showGame('tictactoe')">Tic-Tac-Toe</button>
        <button onclick="showGame('memorymatch')">Memory Match</button>
        <button onclick="showGame('pong')">Ping Pong</button>
        <button onclick="showGame('connectfour')">Connect Four</button>
        <button onclick="showGame('battleship')">Battleship</button>
        <button onclick="showGame('gofish')">Go Fish (Card Game)</button>
        <button onclick="showGame('reversi')">Reversi / Othello</button>
    </div>
    <!-- Tic-Tac-Toe -->
    <div id="tictactoe">
        <h2>Tic Tac Toe: Human vs Computer</h2>
        <div class="ttt-board" id="ttt-board"></div>
        <div id="ttt-result"></div>
        <button onclick="resetTicTacToe()">Restart</button>
        <button onclick="backToMenu()">Back to Menu</button>
    </div>
    <!-- Memory Match -->
    <div id="memorymatch">
        <h2>Memory Match Game</h2>
        <div id="status"></div>
        <div id="moves"></div>
        <div id="memory-board"></div>
        <button id="restart-memorymatch">Restart</button>
        <button onclick="backToMenu()">Back to Menu</button>
    </div>
    <!-- Pong -->
    <div id="pong">
        <h2>Ping Pong - Human vs Computer</h2>
        <canvas id="pong-canvas" width="800" height="600"></canvas>
        <div id="pong-instructions">
            <p>Use UP/DOWN arrows or W/S keys to move</p>
            <p>First to 10 points wins!</p>
            <p>Press ESC to quit</p>
        </div>
        <button onclick="backToMenu()">Back to Menu</button>
    </div>
    <!-- Connect Four -->
    <div id="connectfour">
        <div class="container">
            <h2>Connect Four: Human vs Computer</h2>
            <div id="game-grid"></div>
            <div id="status">Your turn (O)</div>
            <div>
                <button id="restart" class="cf-large-btn">Restart</button>
                <button onclick="backToMenu()" class="cf-large-btn">Back to Menu</button>
            </div>
        </div>
    </div>
    <!-- Battleship -->
    <div id="battleship">
        <h2>Battleship</h2>
        <div id="battleship-status"></div>
        <div class="boards-container">
            <div class="board-wrap">
                <div class="board-label">Your Board</div>
                <div id="player-board" class="board"></div>
            </div>
            <div class="board-wrap">
                <div class="board-label">Computer Board</div>
                <div id="computer-board" class="board"></div>
            </div>
        </div>
        <button id="battleship-restart">Restart</button>
        <button onclick="backToMenu()">Back to Menu</button>
    </div>
    <!-- Go Fish Card Game -->
    <div id="gofish">
      <h1>Go Fish - Card Game</h1>
      <div id="message"></div>
      <div id="deck-count"></div>
      <div>
        <strong>Your Hand:</strong>
        <div id="player-hand" class="hand"></div>
      </div>
      <div>
        <strong>Your Books:</strong>
        <div id="player-books" class="books"></div>
      </div>
      <div>
        <strong>Computer's Books:</strong>
        <div id="computer-books" class="books"></div>
      </div>
      <button id="restart-gofish">Restart</button>
      <button onclick="backToMenu()">Back to Menu</button>
    </div>
    <!-- Reversi / Othello -->
    <div id="reversi">
        <h2>Reversi / Othello</h2>
        <div id="reversi-status"></div>
        <div id="game-board"></div>
        <div id="score"></div>
        <button id="reversi-restart">Restart Game</button>
        <button onclick="backToMenu()">Back to Menu</button>
    </div>

    <script>
        // Menu navigation
        function showGame(game) {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('tictactoe').style.display = (game === 'tictactoe') ? 'block' : 'none';
            document.getElementById('memorymatch').style.display = (game === 'memorymatch') ? 'block' : 'none';
            document.getElementById('pong').style.display = (game === 'pong') ? 'block' : 'none';
            document.getElementById('connectfour').style.display = (game === 'connectfour') ? 'block' : 'none';
            document.getElementById('battleship').style.display = (game === 'battleship') ? 'block' : 'none';
            document.getElementById('gofish').style.display = (game === 'gofish') ? 'block' : 'none';
            document.getElementById('reversi').style.display = (game === 'reversi') ? 'block' : 'none';
            if (game === 'pong') startPong();
            else stopPong();
            if (game === 'tictactoe') resetTicTacToe();
            if (game === 'memorymatch') createMemoryBoard();
            if (game === 'connectfour') initConnectFour();
            if (game === 'battleship') startBattleship();
            if (game === 'reversi') {
              document.getElementById('reversi').style.display = 'block';
              startReversi();
            }
        }
        function backToMenu() {
            document.getElementById('menu').style.display = 'block';
            document.getElementById('tictactoe').style.display = 'none';
            document.getElementById('memorymatch').style.display = 'none';
            document.getElementById('pong').style.display = 'none';
            document.getElementById('connectfour').style.display = 'none';
            document.getElementById('battleship').style.display = 'none';
            document.getElementById('gofish').style.display = 'none';
            document.getElementById('reversi').style.display = 'none';
            stopPong();
        }

        // --- Memory Match ---
        const symbols = ['🐶','🐱','🦊','🐸','🐵','🐼','🦁','🐷'];
        let board = [];
        let firstCard = null, secondCard = null;
        let lockBoard = false;
        let matchedCount = 0;
        let moves = 0;
        function shuffle(array) {
            for(let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        function createMemoryBoard() {
            const memoryBoard = document.getElementById('memory-board');
            memoryBoard.innerHTML = '';
            let cards = symbols.concat(symbols);
            shuffle(cards);
            board = [];
            matchedCount = 0;
            moves = 0;
            firstCard = null;
            secondCard = null;
            lockBoard = false;
            updateStatus('');
            updateMoves();
            for(let i=0; i<cards.length; i++) {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.symbol = cards[i];
                card.dataset.index = i;
                card.innerText = cards[i];
                card.onclick = () => flipCard(card);
                memoryBoard.appendChild(card);
                board.push(card);
                setTimeout(() => { card.classList.remove('flipped'); card.innerText = ''; }, 800);
                setTimeout(() => { card.classList.remove('matched'); }, 800);
                card.classList.add('flipped');
            }
        }
        function flipCard(card) {
            if(lockBoard) return;
            if(card.classList.contains('flipped') || card.classList.contains('matched')) return;
            card.classList.add('flipped');
            card.innerText = card.dataset.symbol;
            if(!firstCard) {
                firstCard = card;
                return;
            }
            if(card === firstCard) return;
            secondCard = card;
            moves++;
            updateMoves();
            lockBoard = true;
            if(firstCard.dataset.symbol === secondCard.dataset.symbol) {
                firstCard.classList.add('matched');
                secondCard.classList.add('matched');
                matchedCount += 2;
                lockBoard = false;
                firstCard = null;
                secondCard = null;
                if(matchedCount === board.length) {
                    updateStatus(`🎉 You won in ${moves} moves!`);
                }
            } else {
                setTimeout(() => {
                    firstCard.classList.remove('flipped');
                    secondCard.classList.remove('flipped');
                    firstCard.innerText = '';
                    secondCard.innerText = '';
                    lockBoard = false;
                    firstCard = null;
                    secondCard = null;
                }, 900);
            }
        }
        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }
        function updateMoves() {
            document.getElementById('moves').innerText = `Moves: ${moves}`;
        }
        document.getElementById('restart-memorymatch').onclick = createMemoryBoard;

        // --- Tic-Tac-Toe ---
        let tttBoard, tttResult, tttCells, tttGameActive, tttCurrentPlayer;
        function resetTicTacToe() {
            tttBoard = document.getElementById('ttt-board');
            tttResult = document.getElementById('ttt-result');
            tttBoard.innerHTML = '';
            tttCells = [];
            tttGameActive = true;
            tttCurrentPlayer = 'X';
            tttResult.textContent = "Your turn (X)";
            for (let i = 0; i < 3; i++) {
                tttCells[i] = [];
                for (let j = 0; j < 3; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'ttt-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.onclick = () => tttClick(i, j);
                    tttBoard.appendChild(cell);
                    tttCells[i][j] = cell;
                }
            }
        }
        function tttClick(row, col) {
            if (!tttGameActive || tttCurrentPlayer !== 'X') return;
            if (tttCells[row][col].textContent === '') {
                tttCells[row][col].textContent = 'X';
                if (tttCheckWinner('X')) {
                    tttResult.textContent = "You win!";
                    tttGameActive = false;
                    return;
                }
                if (tttCheckDraw()) {
                    tttResult.textContent = "It's a draw!";
                    tttGameActive = false;
                    return;
                }
                tttCurrentPlayer = 'O';
                tttResult.textContent = "Computer's turn...";
                setTimeout(tttComputerMove, 500);
            }
        }
        function tttComputerMove() {
            if (!tttGameActive) return;
            let empty = [];
            for (let i = 0; i < 3; i++)
                for (let j = 0; j < 3; j++)
                    if (tttCells[i][j].textContent === '') empty.push([i, j]);
            if (empty.length === 0) return;
            let [row, col] = empty[Math.floor(Math.random() * empty.length)];
            tttCells[row][col].textContent = 'O';
            if (tttCheckWinner('O')) {
                tttResult.textContent = "Computer wins!";
                tttGameActive = false;
                return;
            }
            if (tttCheckDraw()) {
                tttResult.textContent = "It's a draw!";
                tttGameActive = false;
                return;
            }
            tttCurrentPlayer = 'X';
            tttResult.textContent = "Your turn (X)";
        }
        function tttCheckWinner(player) {
            for (let i = 0; i < 3; i++)
                if ([0,1,2].every(j => tttCells[i][j].textContent === player)) return true;
            for (let j = 0; j < 3; j++)
                if ([0,1,2].every(i => tttCells[i][j].textContent === player)) return true;
            if ([0,1,2].every(i => tttCells[i][i].textContent === player)) return true;
            if ([0,1,2].every(i => tttCells[i][2-i].textContent === player)) return true;
            return false;
        }
        function tttCheckDraw() {
            return [].concat(...tttCells).every(cell => cell.textContent !== '');
        }

        // --- Pong Game ---
        let pongRunning = false, pongAnimationId;
        let pongCanvas, pongCtx;
        let paddleWidth = 15, paddleHeight = 90, ballSize = 15;
        let playerPaddle, computerPaddle, ball;
        let playerScore, computerScore;
        let paddleSpeed = 6, ballSpeed = 5;
        let keysPressed = {};
        function startPong() {
            pongCanvas = document.getElementById('pong-canvas');
            pongCtx = pongCanvas.getContext('2d');
            playerPaddle = { x: 30, y: pongCanvas.height/2 - paddleHeight/2, color: '#0090ff' };
            computerPaddle = { x: pongCanvas.width-30-paddleWidth, y: pongCanvas.height/2 - paddleHeight/2, color: '#ff6464' };
            ball = { x: pongCanvas.width/2, y: pongCanvas.height/2, vx: ballSpeed * (Math.random()<0.5?-1:1), vy: ballSpeed * (Math.random()<0.5?-1:1) };
            playerScore = 0; computerScore = 0;
            pongRunning = true;
            window.addEventListener('keydown', pongKeyDown);
            window.addEventListener('keyup', pongKeyUp);
            pongLoop();
        }
        function stopPong() {
            pongRunning = false;
            window.removeEventListener('keydown', pongKeyDown);
            window.removeEventListener('keyup', pongKeyUp);
            if (pongAnimationId) cancelAnimationFrame(pongAnimationId);
        }
        function pongKeyDown(e) {
            keysPressed[e.key.toLowerCase()] = true;
            if (e.key === "Escape") backToMenu();
            if (e.key === " " && (playerScore >= 10 || computerScore >= 10)) startPong();
        }
        function pongKeyUp(e) {
            keysPressed[e.key.toLowerCase()] = false;
        }
        function pongLoop() {
            if (!pongRunning) return;
            if (keysPressed['arrowup'] || keysPressed['w']) playerPaddle.y -= paddleSpeed;
            if (keysPressed['arrowdown'] || keysPressed['s']) playerPaddle.y += paddleSpeed;
            playerPaddle.y = Math.max(0, Math.min(pongCanvas.height-paddleHeight, playerPaddle.y));
            let paddleCenter = computerPaddle.y + paddleHeight/2;
            if (Math.abs(paddleCenter - ball.y) > 20) {
                if (paddleCenter < ball.y) computerPaddle.y += paddleSpeed;
                else computerPaddle.y -= paddleSpeed;
            }
            computerPaddle.y = Math.max(0, Math.min(pongCanvas.height-paddleHeight, computerPaddle.y));
            ball.x += ball.vx;
            ball.y += ball.vy;
            if (ball.y <= 0 || ball.y + ballSize >= pongCanvas.height) ball.vy = -ball.vy;
            if (ball.x <= playerPaddle.x + paddleWidth &&
                    ball.y + ballSize >= playerPaddle.y &&
                    ball.y <= playerPaddle.y + paddleHeight) {
                if (ball.vx < 0) {
                    ball.vx = -ball.vx;
                    let hitPos = ((ball.y + ballSize/2) - (playerPaddle.y + paddleHeight/2)) / paddleHeight;
                    ball.vy += hitPos * 6;
                }
            }
            if (ball.x + ballSize >= computerPaddle.x &&
                    ball.y + ballSize >= computerPaddle.y &&
                    ball.y <= computerPaddle.y + paddleHeight) {
                if (ball.vx > 0) {
                    ball.vx = -ball.vx;
                    let hitPos = ((ball.y + ballSize/2) - (computerPaddle.y + paddleHeight/2)) / paddleHeight;
                    ball.vy += hitPos * 6;
                }
            }
            if (ball.x < 0) {
                computerScore++;
                pongResetBall();
            }
            if (ball.x > pongCanvas.width) {
                playerScore++;
                pongResetBall();
            }
            pongDraw();
            if (playerScore >= 10 || computerScore >= 10) {
                pongDrawGameOver();
                pongRunning = false;
                return;
            }
            pongAnimationId = requestAnimationFrame(pongLoop);
        }
        function pongResetBall() {
            ball.x = pongCanvas.width/2;
            ball.y = pongCanvas.height/2;
            ball.vx = ballSpeed * (Math.random()<0.5?-1:1);
            ball.vy = ballSpeed * (Math.random()<0.5?-1:1);
        }
        function pongDraw() {
            pongCtx.clearRect(0, 0, pongCanvas.width, pongCanvas.height);
            pongCtx.strokeStyle = "#fff";
            pongCtx.setLineDash([10, 10]);
            pongCtx.beginPath();
            pongCtx.moveTo(pongCanvas.width/2, 0);
            pongCtx.lineTo(pongCanvas.width/2, pongCanvas.height);
            pongCtx.stroke();
            pongCtx.setLineDash([]);
            pongCtx.fillStyle = playerPaddle.color;
            pongCtx.fillRect(playerPaddle.x, playerPaddle.y, paddleWidth, paddleHeight);
            pongCtx.fillStyle = computerPaddle.color;
            pongCtx.fillRect(computerPaddle.x, computerPaddle.y, paddleWidth, paddleHeight);
            pongCtx.fillStyle = "#fff";
            pongCtx.beginPath();
            pongCtx.ellipse(ball.x + ballSize/2, ball.y + ballSize/2, ballSize/2, ballSize/2, 0, 0, 2*Math.PI);
            pongCtx.fill();
            pongCtx.font = "74px Arial";
            pongCtx.fillStyle = "#fff";
            pongCtx.fillText(playerScore, pongCanvas.width/4, 80);
            pongCtx.fillText(computerScore, 3*pongCanvas.width/4, 80);
        }
        function pongDrawGameOver() {
            pongCtx.fillStyle = "rgba(0,0,0,0.7)";
            pongCtx.fillRect(0, 0, pongCanvas.width, pongCanvas.height);
            pongCtx.font = "74px Arial";
            pongCtx.fillStyle = "#fff";
            let winner = playerScore >= 10 ? "You Win!" : "Computer Wins!";
            pongCtx.textAlign = "center";
            pongCtx.fillText(winner, pongCanvas.width/2, pongCanvas.height/2);
            pongCtx.font = "36px Arial";
            pongCtx.fillText("Press SPACE to restart or ESC to quit", pongCanvas.width/2, pongCanvas.height/2 + 60);
            pongCtx.textAlign = "start";
        }

        // --- Connect Four ---
        let cf_ROWS = 6;
        let cf_COLS = 7;
        let cf_board = [];
        let cf_buttons = [];
        let cf_currentPlayer = 'O'; // 'O' (Human), 'X' (Computer)
        let cf_gameActive = true;
        function initConnectFour() {
            cf_board = Array.from({ length: cf_ROWS }, () => Array(cf_COLS).fill(''));
            let gridElem = document.getElementById('game-grid');
            gridElem.innerHTML = '';
            document.getElementById('status').textContent = "Your turn (O)";
            cf_gameActive = true;
            cf_buttons = [];
            for (let r = 0; r < cf_ROWS; r++) {
                cf_buttons[r] = [];
                for (let c = 0; c < cf_COLS; c++) {
                    const btn = document.createElement('button');
                    btn.dataset.row = r;
                    btn.dataset.col = c;
                                        btn.disabled = false;
                    btn.onclick = (() => { return () => cf_playerMove(c); })();
                    gridElem.appendChild(btn);
                    cf_buttons[r][c] = btn;
                }
            }
            if (Math.random() < 0.5) {
                document.getElementById('status').textContent = "Computer starts!";
                cf_disableButtons();
                cf_currentPlayer = 'X';
                setTimeout(cf_computerMove, 500);
            } else {
                cf_currentPlayer = 'O';
                cf_enableButtons();
            }
        }
        function cf_playerMove(col) {
            if (!cf_gameActive || cf_currentPlayer !== 'O') return;
            const row = cf_getNextOpenRow(col);
            if (row === -1) return;
            cf_placePiece(row, col, 'O');
            if (cf_checkWin(row, col, 'O')) {
                document.getElementById('status').textContent = "You Win!";
                cf_endGame();
                return;
            }
            if (cf_checkDraw()) {
                document.getElementById('status').textContent = "It's a Draw!";
                cf_endGame();
                return;
            }
            cf_currentPlayer = 'X';
            cf_disableButtons();
            document.getElementById('status').textContent = "Computer's turn...";
            setTimeout(cf_computerMove, 500);
        }
        function cf_computerMove() {
            if (!cf_gameActive || cf_currentPlayer !== 'X') return;
            const availableColumns = [];
            for (let c = 0; c < cf_COLS; c++) {
                if (cf_getNextOpenRow(c) !== -1) availableColumns.push(c);
            }
            if (availableColumns.length === 0) return;
            const col = availableColumns[Math.floor(Math.random() * availableColumns.length)];
            const row = cf_getNextOpenRow(col);
            cf_placePiece(row, col, 'X');
            if (cf_checkWin(row, col, 'X')) {
                document.getElementById('status').textContent = "Computer Wins!";
                cf_endGame();
                return;
            }
            if (cf_checkDraw()) {
                document.getElementById('status').textContent = "It's a Draw!";
                cf_endGame();
                return;
            }
            cf_currentPlayer = 'O';
            cf_enableButtons();
            document.getElementById('status').textContent = "Your turn (O)";
        }
        function cf_placePiece(row, col, piece) {
            cf_board[row][col] = piece;
            cf_buttons[row][col].textContent = piece;
            cf_buttons[row][col].dataset.piece = piece;
            cf_buttons[row][col].disabled = true;
        }
        function cf_getNextOpenRow(col) {
            for (let r = cf_ROWS - 1; r >= 0; r--) {
                if (cf_board[r][col] === '') {
                    return r;
                }
            }
            return -1;
        }
        function cf_checkWin(row, col, piece) {
            for (let c = 0; c < cf_COLS - 3; c++) {
                if (cf_board[row][c] === piece && cf_board[row][c + 1] === piece &&
                    cf_board[row][c + 2] === piece && cf_board[row][c + 3] === piece) {
                    return true;
                }
            }
            for (let r = 0; r < cf_ROWS - 3; r++) {
                if (cf_board[r][col] === piece && cf_board[r + 1][col] === piece &&
                    cf_board[r + 2][col] === piece && cf_board[r + 3][col] === piece) {
                    return true;
                }
            }
            for (let r = 0; r < cf_ROWS - 3; r++) {
                for (let c = 0; c < cf_COLS - 3; c++) {
                    if (cf_board[r][c] === piece && cf_board[r + 1][c + 1] === piece &&
                        cf_board[r + 2][c + 2] === piece && cf_board[r + 3][c + 3] === piece) {
                        return true;
                    }
                }
            }
            for (let r = 3; r < cf_ROWS; r++) {
                for (let c = 0; c < cf_COLS - 3; c++) {
                    if (cf_board[r][c] === piece && cf_board[r - 1][c + 1] === piece &&
                        cf_board[r - 2][c + 2] === piece && cf_board[r - 3][c + 3] === piece) {
                        return true;
                    }
                }
            }
            return false;
        }
        function cf_checkDraw() {
            for (let r = 0; r < cf_ROWS; r++) {
                for (let c = 0; c < cf_COLS; c++) {
                    if (cf_board[r][c] === '') return false;
                }
            }
            return true;
        }
        function cf_endGame() {
            cf_gameActive = false;
            cf_disableButtons();
        }
        function cf_disableButtons() {
            for (let r = 0; r < cf_ROWS; r++) {
                for (let c = 0; c < cf_COLS; c++) {
                    cf_buttons[r][c].disabled = true;
                }
            }
        }
        function cf_enableButtons() {
            for (let r = 0; r < cf_ROWS; r++) {
                for (let c = 0; c < cf_COLS; c++) {
                    if (cf_board[r][c] === '') {
                        cf_buttons[r][c].disabled = false;
                    }
                }
            }
        }
        document.getElementById('restart').onclick = initConnectFour;

        // --- Battleship ---
        const SIZE = 8;
        const SHIPS = [
            { name: "Battleship", size: 4 },
            { name: "Cruiser", size: 3 },
            { name: "Submarine", size: 3 },
            { name: "Destroyer", size: 2 }
        ];
        let playerBoard, computerBoard, playerShips, computerShips, battleshipActive, playerTurn, statusElem;

        function createEmptyBoard() {
            return Array.from({length: SIZE}, () => Array(SIZE).fill(0));
        }

        function placeShipsRandomly() {
            let board = createEmptyBoard();
            let ships = [];
            for (let ship of SHIPS) {
                let placed = false;
                while (!placed) {
                    let isHorizontal = Math.random() < 0.5;
                    let row = Math.floor(Math.random() * (isHorizontal ? SIZE : SIZE - ship.size + 1));
                    let col = Math.floor(Math.random() * (isHorizontal ? SIZE - ship.size + 1 : SIZE));
                    let canPlace = true;
                    for (let i = 0; i < ship.size; i++) {
                        let r = row + (isHorizontal ? 0 : i);
                        let c = col + (isHorizontal ? i : 0);
                        if (board[r][c] !== 0) {
                            canPlace = false;
                            break;
                        }
                    }
                    if (canPlace) {
                        let coords = [];
                        for (let i = 0; i < ship.size; i++) {
                            let r = row + (isHorizontal ? 0 : i);
                            let c = col + (isHorizontal ? i : 0);
                            board[r][c] = ship.name[0];
                            coords.push([r, c, false]);
                        }
                        ships.push({ name: ship.name, size: ship.size, coords });
                        placed = true;
                    }
                }
            }
            return { board, ships };
        }

        function drawBoards() {
            let playerBoardElem = document.getElementById('player-board');
            playerBoardElem.innerHTML = '';
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    let val = playerBoard[r][c];
                    if (typeof val === 'string' && val.match(/[BCSD]/)) cell.classList.add('ship');
                    if (val === 'X') cell.classList.add('hit'), cell.textContent = '✕';
                    if (val === 'O') cell.classList.add('miss'), cell.textContent = '•';
                    playerShips.forEach(ship => {
                        if (ship.coords.every(x => x[2])) {
                            ship.coords.forEach(([rr, cc]) => {
                                if (rr === r && cc === c) cell.classList.add('sunk');
                            });
                        }
                    });
                    playerBoardElem.appendChild(cell);
                }
            }
            let computerBoardElem = document.getElementById('computer-board');
            computerBoardElem.innerHTML = '';
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell target';
                    let val = computerBoard[r][c];
                    if (val === 'X') cell.classList.add('hit'), cell.textContent = '✕', cell.classList.remove('target');
                    if (val === 'O') cell.classList.add('miss'), cell.textContent = '•', cell.classList.remove('target');
                    computerShips.forEach(ship => {
                        if (ship.coords.every(x => x[2])) {
                            ship.coords.forEach(([rr, cc]) => {
                                if (rr === r && cc === c) {
                                    cell.classList.add('sunk');
                                    cell.textContent = '✕';
                                    cell.classList.remove('target');
                                }
                            });
                        }
                    });
                    if (battleshipActive && playerTurn && val !== 'X' && val !== 'O') {
                        cell.onclick = () => playerFire(r, c);
                    }
                    computerBoardElem.appendChild(cell);
                }
            }
        }

        function playerFire(r, c) {
            if (!battleshipActive || !playerTurn || computerBoard[r][c] === 'X' || computerBoard[r][c] === 'O') return;
            let hit = false;
            for (let ship of computerShips) {
                for (let coord of ship.coords) {
                    if (coord[0] === r && coord[1] === c && !coord[2]) {
                        coord[2] = true;
                        computerBoard[r][c] = 'X';
                        hit = true;
                        if (ship.coords.every(x => x[2])) {
                            setBattleshipStatus(`You sank the computer's ${ship.name}!`);
                        } else {
                            setBattleshipStatus('Hit!');
                        }
                        break;
                    }
                }
            }
            if (!hit) {
                computerBoard[r][c] = 'O';
                setBattleshipStatus('Miss!');
            }
            drawBoards();
            if (checkBattleshipWin(computerShips)) {
                setBattleshipStatus('🎉 You win! All enemy ships sunk!');
                battleshipActive = false;
                return;
            }
            playerTurn = false;
            setTimeout(computerMove, 800);
        }

        function computerMove() {
            if (!battleshipActive) return;
            let available = [];
            for (let r = 0; r < SIZE; r++)
                for (let c = 0; c < SIZE; c++)
                    if (playerBoard[r][c] !== 'X' && playerBoard[r][c] !== 'O') available.push([r, c]);
            if (available.length === 0) return;
            let [r, c] = available[Math.floor(Math.random() * available.length)];
            let hit = false;
            for (let ship of playerShips) {
                for (let coord of ship.coords) {
                    if (coord[0] === r && coord[1] === c && !coord[2]) {
                        coord[2] = true;
                        playerBoard[r][c] = 'X';
                        hit = true;
                        setBattleshipStatus("Computer hit your ship!");
                        break;
                    }
                }
            }
            if (!hit) {
                playerBoard[r][c] = 'O';
                setBattleshipStatus("Computer missed!");
            }
            drawBoards();
            if (checkBattleshipWin(playerShips)) {
                setBattleshipStatus('😢 Computer wins! All your ships sunk!');
                battleshipActive = false;
                return;
            }
            playerTurn = true;
        }

        function checkBattleshipWin(ships) {
            return ships.every(ship => ship.coords.every(coord => coord[2]));
        }

        function setBattleshipStatus(msg) {
            statusElem.textContent = msg;
        }

        function startBattleship() {
            ({ board: playerBoard, ships: playerShips } = placeShipsRandomly());
            ({ board: computerBoard, ships: computerShips } = placeShipsRandomly());
            battleshipActive = true;
            playerTurn = true;
            statusElem = document.getElementById('battleship-status');
            setBattleshipStatus("Your turn! Click a cell on the Computer's board to fire.");
            drawBoards();
        }

        document.getElementById('battleship-restart').onclick = startBattleship;
        // ---Go Fish (Card Game)---
        const GOFISH_RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        let gofishDeck, gofishPlayerHand, gofishComputerHand, gofishPlayerBooks, gofishComputerBooks, gofishTurn, gofishGameOver;

        function gofishMakeDeck() {
            let d = [];
            for (let r of GOFISH_RANKS) for (let s of [0,1,2,3]) d.push(r);
            return gofishShuffle(d);
        }
        function gofishShuffle(arr) {
            for (let i = arr.length-1; i > 0; i--) {
            const j = Math.floor(Math.random()*(i+1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }
        function gofishCountRank(hand, rank) { return hand.filter(c => c === rank).length; }
        function gofishRemoveRank(hand, rank) {
            const taken = hand.filter(c => c === rank);
            const rest = hand.filter(c => c !== rank);
            return [taken, rest];
        }
        function gofishHasBook(hand, rank) {
            return gofishCountRank(hand, rank) === 4;
        }
        function gofishFindBooks(hand) {
            let books = [];
            for (let r of GOFISH_RANKS) if (gofishHasBook(hand, r)) books.push(r);
            return books;
        }
        function gofishRemoveBooks(hand) {
            let books = gofishFindBooks(hand);
            let h = hand.slice();
            for (let b of books) h = h.filter(c => c !== b);
            return [h, books];
        }
        function gofishInitGame() {
            gofishDeck = gofishMakeDeck();
            gofishPlayerHand = gofishDeck.splice(0, 7);
            gofishComputerHand = gofishDeck.splice(0, 7);
            gofishPlayerBooks = [];
            gofishComputerBooks = [];
            gofishTurn = "player";
            gofishGameOver = false;
            gofishCheckBooks();
            gofishRender();
            gofishSetMessage("Your turn! Click a card rank to ask for.");
        }
        function gofishCheckBooks() {
            let [pHand, pNewBooks] = gofishRemoveBooks(gofishPlayerHand);
            let [cHand, cNewBooks] = gofishRemoveBooks(gofishComputerHand);
            if (pNewBooks.length) gofishPlayerBooks.push(...pNewBooks);
            if (cNewBooks.length) gofishComputerBooks.push(...cNewBooks);
            gofishPlayerHand = pHand; gofishComputerHand = cHand;
        }
        function gofishGameEnd() {
            gofishGameOver = true;
            let result = "";
            if (gofishPlayerBooks.length > gofishComputerBooks.length) result = "You win!";
            else if (gofishPlayerBooks.length < gofishComputerBooks.length) result = "Computer wins!";
            else result = "It's a tie!";
            gofishSetMessage(`Game Over! ${result} (You: ${gofishPlayerBooks.length} | Computer: ${gofishComputerBooks.length})`);
        }
        function gofishDrawCard(hand) {
            if (gofishDeck.length) hand.push(gofishDeck.pop());
        }
        function gofishPlayerAsk(rank) {
            if (gofishGameOver || gofishTurn !== "player") return;
            if (!gofishPlayerHand.includes(rank)) {
            gofishSetMessage("You don't have that rank!");
            return;
            }
            let [taken, newComputerHand] = gofishRemoveRank(gofishComputerHand, rank);
            gofishComputerHand = newComputerHand;
            if (taken.length) {
            gofishPlayerHand.push(...taken);
            gofishSetMessage(`Computer had ${taken.length} ${rank}(s)! You go again.`);
            gofishCheckBooks();
            gofishRender();
            if (gofishPlayerHand.length === 0) {
                if (gofishDeck.length) gofishDrawCard(gofishPlayerHand);
                gofishCheckBooks(); gofishRender();
                if (gofishPlayerHand.length === 0) gofishGameEnd();
            }
            } else {
            gofishSetMessage("Go Fish! You draw a card.");
            gofishDrawCard(gofishPlayerHand);
            gofishCheckBooks();
            gofishRender();
            gofishTurn = "computer";
            setTimeout(gofishComputerTurn, 800);
            }
            if (gofishPlayerBooks.length + gofishComputerBooks.length === 13) gofishGameEnd();
        }
        function gofishComputerTurn() {
            if (gofishGameOver) return;
            if (gofishComputerHand.length === 0) {
            if (gofishDeck.length) gofishDrawCard(gofishComputerHand);
            gofishCheckBooks(); gofishRender();
            if (gofishComputerHand.length === 0) { gofishGameEnd(); return; }
            }
            let rank = gofishComputerHand[Math.floor(Math.random() * gofishComputerHand.length)];
            let [taken, newPlayerHand] = gofishRemoveRank(gofishPlayerHand, rank);
            gofishPlayerHand = newPlayerHand;
            if (taken.length) {
            gofishComputerHand.push(...taken);
            gofishSetMessage(`Computer asks for ${rank}. You had ${taken.length}. Computer goes again.`);
            gofishCheckBooks();
            gofishRender();
            if (gofishComputerBooks.length + gofishPlayerBooks.length === 13) { gofishGameEnd(); return; }
            setTimeout(gofishComputerTurn, 900);
            } else {
            gofishSetMessage(`Computer asks for ${rank}. Go Fish!`);
            gofishDrawCard(gofishComputerHand);
            gofishCheckBooks();
            gofishRender();
            gofishTurn = "player";
            if (gofishPlayerHand.length === 0) {
                if (gofishDeck.length) gofishDrawCard(gofishPlayerHand);
                gofishCheckBooks(); gofishRender();
                if (gofishPlayerHand.length === 0) gofishGameEnd();
            }
            if (gofishComputerBooks.length + gofishPlayerBooks.length === 13) gofishGameEnd();
            }
        }
        function gofishRender() {
            let ph = document.getElementById('player-hand');
            ph.innerHTML = '';
            let seen = new Set();
            for (let r of gofishPlayerHand) {
            if (!seen.has(r)) {
                let btn = document.createElement('div');
                btn.className = 'card';
                btn.textContent = r;
                btn.onclick = () => gofishPlayerAsk(r);
                ph.appendChild(btn);
                seen.add(r);
            }
            }
            document.getElementById('player-books').textContent = gofishPlayerBooks.join(' ');
            document.getElementById('computer-books').textContent = gofishComputerBooks.join(' ');
            document.getElementById('deck-count').textContent = `Deck: ${gofishDeck.length} cards`;
        }
        function gofishSetMessage(msg) {
            document.getElementById('message').textContent = msg;
        }

        // --- Go Fish integration with menu/buttons ---
        function showGoFish() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('tictactoe').style.display = 'none';
            document.getElementById('memorymatch').style.display = 'none';
            document.getElementById('pong').style.display = 'none';
            document.getElementById('connectfour').style.display = 'none';
            document.getElementById('battleship').style.display = 'none';
            document.getElementById('reversi').style.display = 'none';
            document.getElementById('gofish').style.display = 'block';
            gofishInitGame();
        }
        // Replace menu button to use showGoFish
        document.querySelectorAll('#menu button').forEach(btn => {
            if (btn.textContent.includes('Go Fish')) btn.onclick = showGoFish;
        });
        // Restart button
        document.getElementById('restart-gofish').onclick = gofishInitGame;
        // Back to menu button
        document.querySelector('#gofish button[onclick*="backToMenu"]').onclick = function() {
            document.getElementById('gofish').style.display = 'none';
            document.getElementById('menu').style.display = 'block';
        };
         // --- Reversi / Othello ---
        const REVERSI_SIZE = 8;
        const EMPTY = 0, BLACK = 1, WHITE = 2;
        const DIRS = [
            [-1,-1],[-1,0],[-1,1],
            [0,-1],       [0,1],
            [1,-1],[1,0],[1,1]
        ];
        let reversiBoard, reversiTurn, reversiValidMoves, reversiGameOver;

        function startReversi() {
            reversiInitBoard();
            reversiRender();
            setReversiStatus((reversiTurn === BLACK ? "Computer (Black)'s turn..." : "Your turn (White)"));
            if (reversiTurn === BLACK) setTimeout(reversiComputerMove, 500); // Computer starts
        }

        function reversiInitBoard() {
            reversiBoard = Array.from({ length: REVERSI_SIZE }, _ => Array(REVERSI_SIZE).fill(EMPTY));
            reversiBoard[3][3] = WHITE;
            reversiBoard[4][4] = WHITE;
            reversiBoard[3][4] = BLACK;
            reversiBoard[4][3] = BLACK;
            reversiTurn = BLACK;
            reversiGameOver = false;
            reversiUpdateValidMoves();
        }

        function reversiInBounds(x, y) {
            return x >= 0 && y >= 0 && x < REVERSI_SIZE && y < REVERSI_SIZE;
        }

        function reversiOpponent(p) {
            return p === BLACK ? WHITE : BLACK;
        }

        function reversiIsValidMove(x, y, p) {
            if (reversiBoard[x][y] !== EMPTY) return false;
            for (const [dx, dy] of DIRS) {
                let i = x + dx, j = y + dy, found = false;
                while (reversiInBounds(i, j) && reversiBoard[i][j] === reversiOpponent(p)) {
                    i += dx;
                    j += dy;
                    found = true;
                }
                if (found && reversiInBounds(i, j) && reversiBoard[i][j] === p) return true;
            }
            return false;
        }

        function reversiGetValidMoves(p) {
            const moves = [];
            for (let x = 0; x < REVERSI_SIZE; ++x)
                for (let y = 0; y < REVERSI_SIZE; ++y)
                    if (reversiIsValidMove(x, y, p)) moves.push([x, y]);
            return moves;
        }

        function reversiFlipPieces(x, y, p) {
            for (const [dx, dy] of DIRS) {
                let i = x + dx, j = y + dy, toFlip = [];
                while (reversiInBounds(i, j) && reversiBoard[i][j] === reversiOpponent(p)) {
                    toFlip.push([i, j]);
                    i += dx;
                    j += dy;
                }
                if (toFlip.length && reversiInBounds(i, j) && reversiBoard[i][j] === p)
                    for (const [fx, fy] of toFlip) reversiBoard[fx][fy] = p;
            }
        }

        function reversiPlayMove(x, y, player) {
            if (!reversiIsValidMove(x, y, player) || reversiGameOver) return false;
            reversiBoard[x][y] = player;
            reversiFlipPieces(x, y, player);
            reversiTurn = reversiOpponent(player);
            reversiUpdateValidMoves();
            if (reversiValidMoves.length === 0) {
                reversiTurn = reversiOpponent(reversiTurn);
                reversiUpdateValidMoves();
                if (reversiValidMoves.length === 0) {
                    reversiGameOver = true;
                    reversiRender();
                    return true;
                }
            }
            reversiRender();
            return true;
        }

        function reversiUpdateValidMoves() {
            reversiValidMoves = reversiGetValidMoves(reversiTurn);
        }

        function reversiCountPieces() {
            let black = 0, white = 0;
            for (let x = 0; x < REVERSI_SIZE; ++x)
                for (let y = 0; y < REVERSI_SIZE; ++y)
                    if (reversiBoard[x][y] === BLACK) black++;
                    else if (reversiBoard[x][y] === WHITE) white++;
            return { black, white };
        }

        // Simple AI for computer (Black): pick a random valid move, prefer max flips
        function reversiComputerMove() {
            if (reversiTurn !== BLACK || reversiGameOver) return;
            reversiUpdateValidMoves();
            if (reversiValidMoves.length === 0) return;
            let bestMoves = [], maxFlips = -1;
            for (const [x, y] of reversiValidMoves) {
                let flips = reversiCountFlips(x, y, BLACK);
                if (flips > maxFlips) {
                    bestMoves = [[x, y]];
                    maxFlips = flips;
                } else if (flips === maxFlips) {
                    bestMoves.push([x, y]);
                }
            }
            const [x, y] = bestMoves[Math.floor(Math.random() * bestMoves.length)];
            reversiPlayMove(x, y, BLACK);
            if (reversiTurn === BLACK && !reversiGameOver) setTimeout(reversiComputerMove, 300);
        }

        function reversiCountFlips(x, y, player) {
            let total = 0;
            for (const [dx, dy] of DIRS) {
                let i = x + dx, j = y + dy, flips = 0;
                while (reversiInBounds(i, j) && reversiBoard[i][j] === reversiOpponent(player)) {
                    flips++;
                    i += dx;
                    j += dy;
                }
                if (flips && reversiInBounds(i, j) && reversiBoard[i][j] === player) total += flips;
            }
            return total;
        }

        function reversiHandleHumanMove(x, y) {
            if (reversiTurn !== WHITE || reversiGameOver) return;
            if (reversiPlayMove(x, y, WHITE)) {
                if (reversiTurn === BLACK && !reversiGameOver) setTimeout(reversiComputerMove, 400);
            }
        }

        function reversiRender() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';
            const boardDiv = document.createElement('div');
            boardDiv.className = 'board';

            for (let x = 0; x < REVERSI_SIZE; ++x) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'row';
                for (let y = 0; y < REVERSI_SIZE; ++y) {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'cell';
                    cellDiv.dataset.x = x;
                    cellDiv.dataset.y = y;

                    if (reversiTurn === WHITE && reversiIsValidMove(x, y, WHITE) && !reversiGameOver) {
                        cellDiv.classList.add('valid');
                    }

                    if (reversiBoard[x][y] === BLACK || reversiBoard[x][y] === WHITE) {
                        const piece = document.createElement('div');
                        piece.className = 'piece ' + (reversiBoard[x][y] === BLACK ? 'black' : 'white');
                        cellDiv.appendChild(piece);
                    }

                    cellDiv.onclick = () => reversiHandleHumanMove(x, y);
                    rowDiv.appendChild(cellDiv);
                }
                boardDiv.appendChild(rowDiv);
            }
            gameBoard.appendChild(boardDiv);

            const { black, white } = reversiCountPieces();
            document.getElementById('score').textContent = `Computer (Black): ${black}   You (White): ${white}`;

            let turnText = '';
            if (reversiGameOver) {
                if (black > white) turnText = 'Game Over! Computer (Black) wins!';
                else if (white > black) turnText = 'Game Over! You (White) win!';
                else turnText = 'Game Over! It\'s a tie!';
            } else {
                turnText = (reversiTurn === BLACK ? "Computer (Black)'s turn..." : "Your turn (White)");
                if (reversiValidMoves.length === 0)
                    turnText += ' — No moves! Skipping turn...';
            }
            setReversiStatus(turnText);
        }

        function setReversiStatus(msg) {
            document.getElementById('reversi-status').textContent = msg;
        }

        document.getElementById('reversi-restart').onclick = startReversi;
        
        // Show menu on load
        window.onload = function() {
            document.getElementById('menu').style.display = 'block';
        };
    </script>
</body>
</html>

